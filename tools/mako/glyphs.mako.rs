<%! from datetime import datetime %>
// DO NOT MODIFY!
//
// This file is automatically generated by the ../tools/parse-unicode-math.py file using the
// unicode-math-table.tex file taken from `unicode-math` on CTAN. If you find a bug
// in this file, please modify ../tools/parse-unicode-math.py accordingly instead.
//
// FIXME: Switch to PHF when avialable on stable.  Benchmarks shows it is slightly
//   faster with this dataset.
//
// Font: \
// Modified: ${datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
use static_map;
use font_types::{Glyph, BBox};

pub static GLYPHS: static_map::Map<u32, Glyph> = static_map! {
    Default: Glyph { unicode: 0x0000_u32, bbox: BBox(fontunit!(0), fontunit!(0), fontunit!(0), fontunit!(0)), attachment: fontunit!(0), advance: fontunit!(0), lsb: fontunit!(0), italics: fontunit!(0) },

%for glyph in sorted(glyphs.values(), key=lambda val: val['usv']):
    ${'0x%04x' % glyph['usv']}_u32 => Glyph { unicode: ${'0x%04x' % glyph['usv']}_u32, bbox: BBox(fontunit!(${glyph['xmin']}), fontunit!(${glyph['ymin']}), fontunit!(${glyph['xmax']}), fontunit!(${glyph['ymax']})), attachment: fontunit!(${glyph['attachment']}), advance: fontunit!(${glyph['advance']}), lsb: fontunit!(${glyph['lsb']}), italics: fontunit!(${glyph['italics']}) },
%endfor

    // SHIM
%for (new, glyph) in shim:
    ${'0x%04x' % new}_u32 => Glyph { unicode: ${'0x%04x' % glyph['usv']}_u32, bbox: BBox(fontunit!(${glyph['xmin']}), fontunit!(${glyph['ymin']}), fontunit!(${glyph['xmax']}), fontunit!(${glyph['ymax']})), attachment: fontunit!(${glyph['attachment']}), advance: fontunit!(${glyph['advance']}), lsb: fontunit!(${glyph['lsb']}), italics: fontunit!(${glyph['italics']}) },
%endfor
};
