###
# Parse unicode-math-table.tex
#

header = """\
// DO NOT MODIFY!
//
// This file is automatically generated by the ../tools/parse-unicode-math.py file using the
// unicode-math-table.tex file taken from `unicode-math` on CTAN. If you find a bug
// in this file, please modify ../tools/parse-unicode-math.py accordingly instead.
//
// FIXME: We should probably use the official unicode standards source.

use static_map;
use font_types::{Symbol, AtomType};

pub static SYMBOLS: static_map::Map<&'static str, Symbol> = static_map! {
    Default: Symbol { unicode: 0x00, atom_type: AtomType::Accent },
"""

# Convert ../unicode-math-table.tex atomtype to our AtomType.
convert_type = {
    "mathalpha": "Alpha",
    "mathpunct": "Punctuation",
    "mathopen": "Open",
    "mathclose": "Close",
    "mathord": "Ordinal",
    "mathbin": "Binary",
    "mathrel": "Relation",
    "mathop": "Operator",
    "mathfence": "Fence",
    "mathover": "Over",
    "mathunder": "Under",
    "mathaccent": "Accent",
    "mathaccentwide": "AccentWide",
    "mathbotaccent": "BotAccent",
    "mathbotaccentwide": "BotAccentWide",
}

# The following operators have `\limits` by default
operator_limits = {
    "coprod",
    "bigvee",
    "bigwedge",
    "biguplus",
    "bigcap",
    "bigcup",
    "prod",
    "sum",
    "bigotimes",
    "bigoplus",
    "bigodot",
    "bigsqcup",
}

additional_symbols = [
    ("Alpha",   ("0x391", "Alpha")),
    ("Beta",    ("0x392", "Alpha")),
    ("Gamma",   ("0x393", "Alpha")),
    ("Delta",   ("0x394", "Alpha")),
    ("Epsilon", ("0x395", "Alpha")),
    ("Zeta",    ("0x396", "Alpha")),
    ("Eta",     ("0x397", "Alpha")),
    ("Theta",   ("0x398", "Alpha")),
    ("Iota",    ("0x399", "Alpha")),
    ("Kappa",   ("0x39A", "Alpha")),
    ("Lambda",  ("0x39B", "Alpha")),
    ("Mu",      ("0x39C", "Alpha")),
    ("Nu",      ("0x39D", "Alpha")),
    ("Xi",      ("0x39E", "Alpha")),
    ("Omicron", ("0x39F", "Alpha")),
    ("Pi",      ("0x3A0", "Alpha")),
    ("Rho",     ("0x3A1", "Alpha")),

    ("Sigma",   ("0x3A3", "Alpha")),
    ("Tau",     ("0x3A4", "Alpha")),
    ("Upsilon", ("0x3A5", "Alpha")),
    ("Phi",     ("0x3A6", "Alpha")),
    ("Chi",     ("0x3A7", "Alpha")),
    ("Psi",     ("0x3A8", "Alpha")),
    ("Omega",   ("0x3A9", "Alpha")),

    ("alpha",   ("0x3B1", "Alpha")),
    ("beta",    ("0x3B2", "Alpha")),
    ("gamma",   ("0x3B3", "Alpha")),
    ("delta",   ("0x3B4", "Alpha")),
    ("epsilon", ("0x3B5", "Alpha")),
    ("zeta",    ("0x3B6", "Alpha")),
    ("eta",     ("0x3B7", "Alpha")),
    ("theta",   ("0x3B8", "Alpha")),
    ("iota",    ("0x3B9", "Alpha")),
    ("kappa",   ("0x3BA", "Alpha")),
    ("lambda",  ("0x3BB", "Alpha")),
    ("mu",      ("0x3BC", "Alpha")),
    ("nu",      ("0x3BD", "Alpha")),
    ("xi",      ("0x3BE", "Alpha")),
    ("omicron", ("0x3BF", "Alpha")),
    ("pi",      ("0x3C0", "Alpha")),
    ("rho",     ("0x3C1", "Alpha")),

    ("sigma",   ("0x3C3", "Alpha")),
    ("tau",     ("0x3C4", "Alpha")),
    ("upsilon", ("0x3C5", "Alpha")),
    ("phi",     ("0x3C6", "Alpha")),
    ("chi",     ("0x3C7", "Alpha")),
    ("psi",     ("0x3C8", "Alpha")),
    ("omega",   ("0x3C9", "Alpha")),
]

# TeX -> Unicode template
template = '    "{}" => Symbol {{ unicode: 0x{:X}, atom_type: AtomType::{} }}, // {}\n'

def gen_symbols(font, out):
    cmap = font['cmap'].getcmap(3, 10).cmap

    # Parse 'unicode-math-table.tex'.  Store relavent information in
    # `symbols` as 4-tuples:
    #     (TeX command, Id, AtomType, Unicode, Description)
    symbols = []
    with open('unicode-math-table.tex', 'r') as f:
        for line in f:
            code = int("0x" + line[20:25], 16)
            cmd = line[28:53].strip()

            cursor = 56
            while line[cursor] != '}':
                cursor += 1
            atom = line[56:cursor]

            cursor += 2  # Skip next `}{` sequence
            desc = line[cursor:-3]

            if code not in cmap.keys():
                print("Unable to find 0x{:X} -- {}.".format(code, desc))
                continue

            symbols.append([cmd, code, convert_type[atom], code, desc])

    # Write '.../syc/symbols.rs'
    with open(out + "symbols.rs", 'w', newline='\n') as f:
        f.write(header)
        f.write("    // unicode-math.dtx command table\n")
        for tpl in symbols:
            # For operators, we annotate if they have limits or not on default
            if tpl[2] == "Operator":
                tpl[2] += "({})".format(str(tpl[0] in operator_limits).lower())
            f.write(template.format(*tpl))

        f.write("    // Additional commands from TeX\n")
        for name, (code, ty) in additional_symbols:
            code = int(code, 16)
            if code not in cmap:
                print("Missing greek glyph: {}, {}".format(code, name))
                continue
            f.write(template.format(name, code, ty, code, ""))
        f.write('};')


if __name__ == "__main__":
    import sys
    from fontTools.ttLib import TTFont

    USAGE = "usage: python3 symbols.py font.otf\n" \
            "`symbols.py` will extract the Math table constants " \
            "and generate their correspoding rust constants in " \
            "`symbols.rs`."

    if len(sys.argv) < 2:
        print(USAGE)
        sys.exit(2)

    if sys.argv[1] == "-h" or sys.argv[1] == "--help":
        print(USAGE)
        sys.exit(0)

    print("Generating variant.rs")
    FONT = TTFont(sys.argv[1])
    gen_symbols(FONT)
